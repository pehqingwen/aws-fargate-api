name: deploy

on:
  push:
    branches: [ main ]

env:
  AWS_REGION: ap-southeast-1
  ECR_REPO: fargate-api
  CLUSTER: fargate-api-cluster
  SERVICE: fargate-api-svc
  # adjust if your Terraform lives elsewhere
  TF_DIR: terraform/envs/dev
  APP_DIR: app
  IMAGE_TAG: ${{ github.sha }}

permissions:
  id-token: write   # for OIDC
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}   # e.g. arn:aws:iam::<acct>:role/GH-OIDC-Deploy
          aws-region: ${{ env.AWS_REGION }}

      # Build & push the image (no local Docker creds needed)
      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        working-directory: ${{ env.APP_DIR }}
        run: |
          set -e
          IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPO }}:${{ env.IMAGE_TAG }}"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
          docker build -t "$IMAGE" .
          docker push "$IMAGE"

      # Terraform apply infra/service
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        working-directory: ${{ env.TF_DIR }}
        run: terraform init -input=false

      - name: Terraform Plan
        working-directory: ${{ env.TF_DIR }}
        run: terraform plan -input=false

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        working-directory: ${{ env.TF_DIR }}
        run: terraform apply -auto-approve -input=false

      # Tell ECS to use the new image (force rollout)
      - name: Update ECS service to new taskdef/image
        run: |
          set -e
          # If your task definition template references :latest, ensure your TD is updated to use env.IMAGE_TAG (recommended).
          # Otherwise we still force a new deployment to pick the latest :latest.
          aws ecs update-service \
            --cluster "${{ env.CLUSTER }}" \
            --service "${{ env.SERVICE }}" \
            --force-new-deployment

      # Watch ECS events briefly (great for debugging)
      - name: Watch ECS events (2 minutes)
        run: |
          end=$((SECONDS+120))
          while [ $SECONDS -lt $end ]; do
            aws ecs describe-services --cluster "${{ env.CLUSTER }}" --services "${{ env.SERVICE }}" \
              --query "services[0].events[0:3].[createdAt,message]" --output table || true
            sleep 10
          done

      # Wait until service is stable
      - name: Wait for ECS service to stabilize
        run: |
          aws ecs wait services-stable \
            --cluster "${{ env.CLUSTER }}" \
            --services "${{ env.SERVICE }}"

      # Smoke test through ALB
      - name: Get ALB DNS
        id: alb
        run: |
          ALB_ARN=$(aws elbv2 describe-load-balancers \
            --names fargate-api-alb \
            --query "LoadBalancers[0].LoadBalancerArn" --output text)
          DNS=$(aws elbv2 describe-load-balancers --load-balancer-arns "$ALB_ARN" \
            --query "LoadBalancers[0].DNSName" --output text)
          echo "dns=$DNS" >> $GITHUB_OUTPUT

      - name: Smoke test /healthz
        run: |
          set -e
          curl -fsS "http://${{ steps.alb.outputs.dns }}/healthz"

      - name: Smoke test /api/hello
        run: |
          set -e
          curl -fsS "http://${{ steps.alb.outputs.dns }}/api/hello"
